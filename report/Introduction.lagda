\documentclass[main.tex]{subfiles}
\begin{document}

\section{Introduction}
Our goal is to define PCF, its operational semantics, and the denotational semantics via the Scott model. We proceed to show that the denotational semantics are computationally adequate with respect to the operational semantics. These are not new proofs, and we will be staying close to Streicher's \emph{Domain-Theoretic Foundations of Functional Programming} \cite{domaintheoreticfoundations}. We deviate in our choice of variable representation, and that we work in Voevodsky’s constructive univalent type theory \cite{HoTTbook}, however most proofs follow closely.

We shall be using a dependently typed programming language called Agda. Due to its strong typing and support for dependent types, we can use Agda as a proof assistant. This is since from the Curry-Howard correspondence, we can express logical specifications using dependent types, and the programs we define are proofs \cite{howard:80}. During our developments, we experience the differences between proofs on paper, and developing our proofs in Agda. We see times where we are required to formalise properties which may be left out of paper proofs - sometimes things which may be considered trivial. We also appreciate the support Agda provides, such as reminding us of our assumptions at a particular stage in a proof, or allowing us to easily case split and ensure we account for every possible case in our proof.

We build upon Tom de Jong's current formalisation of domain theory in Agda, which he used to define the Scott model for a combinatorial version of PCF \cite{jong2019scott}. We differ from Tom de Jong's implementation of PCF as we provide support for lambda abstraction and variables. For use when we construct our model, we formalise the product between DCPOs, currying of continuous functions, and uncurrying of continuous functions. We also make use of Mart\'in Escard\'o's developments in Agda of univalent type theory \cite{TypeTopology} and the lifting monad \cite{escardoknapppartial}. 

From this, we then are able to construct the Scott model of PCF \cite{Scott1993}. We show that the operational semantics are correct with respect to the Scott model, i.e. terms $P$ and $V$ are denotationally equal whenever $P ⇓ V$. Finally, we then show that the Scott model is computationally adequate with respect to the operational semantics, i.e. $P ⇓ \underline{n}$ whenever the terms $P$ and $n$ are denotationally equal.

\subsection*{Why use a proof assistant?}
One may wonder why we are bothering to formalise these properties in Agda when there are papers describing proofs of these properties already. The first motivation behind this surrounds how we know that proofs are correct. When we write proofs on paper, we rely on humans to check the proofs, and naturally this introduces human error. There are many examples through history of proofs which claim to show a property, only for it to be refuted at a later date. Even more related to our case, when Sébastien Gouëzel was formalising a proof by Vladimir Shchur in Isabelle, he managed to find a gap in the proof. Later, they published a joint paper to correct this gap \cite{GOUEZEL20191258}. It could be argued that the same discovery could be made without the proof assistant, and that argument would be correct. However, if we formalise our proof in a proof assistant, then these errors would not occur (assuming the compiler is correct). Also, it may take years for a human to find an error in a proof, whereas a computer can decide much quicker. 

Using a proof assistant requires that we formalise and prove small details which we may not normally formalise on paper. In mathematics, it's normal to make large steps in proofs, and sometimes leave out proofs that may be seen as trivial - ``left as an exercise for the reader'' is a common phrase. Proof assistants do not allow this. We must explicitly prove every property we are interested in, and each detail of a proof must be present so it can be machine-checked. During our developments, we will see times where we must come up with a proof of some properties that are mentioned to be true, but no actual proof is given in the papers which we are staying close to.

There are also some convenience features which some proof assistants provide that we lack when proving properties on paper. During our developments, we will see structural induction which provides us with many different cases. On paper, we would have to manually ensure we have considered every possible case, and sometimes this may be difficult as there can be many. If we miss any cases, our proof is incomplete. When using Agda as our proof assistant, we can tell Agda to generate the cases for us, called case splitting. Agda will also warn us if we have missed any cases in our proof. Another feature which makes proof assistants extremely useful is that they can provide us with our current assumptions at a particular stage in a proof. This is especially useful if we are deep in a lengthy proof. On paper, this could become difficult to keep track of and a cognitive burden, as opposed to allowing the proof assistant to keep track of this.


\end{document}
