\documentclass[main.tex]{subfiles}

\begin{document}

\section{Evaluation}
During this investigation, we have had to learn many new skills and concepts. The obvious skill we have had to develop throughout this project is our proficiency with developing our proofs in Agda. In the beginning, our Agda knowledge was minimal. There are many Agda features we have had to explore during this project. We experienced times where we used anonymous modules to make assumptions across many proofs without having to explicitly list the assumptions in each individual proof. We also had to become familiar with using Agda's universes, which we renamed to terminology closer to that used in type theory like in Mart\'in Escard\'o's developments. We gained a deeper understanding of how we can transfer proofs from paper to Agda using these concepts, and as a result our Agda skills vastly improved towards the end of our investigations, learning where Agda differs from paper proofs. A particular example of where we noticed this difference was when constructing the substitution lemma in \cref{sublem}, where we saw that it was not as straightforward to translate to Agda in our setting as it sounds by Streicher.
\paragraph*{The learning curve.}When we first began this project, the proofs were suboptimal in the sense that many could have been shortened considerably, and many steps were unnecessary. As our understanding of Agda and the environment we were working in grew, such as developing a deeper understanding of domain theory and the current developments by Tom de Jong, if we were to come back to the proofs, it would be possible to write them in a more succinct and elegant manner. A good example of a proof which was rewritten at the end of the project was the proof that \AgdaFunction{eval} was continuous in its first argument, which is shown in \cref{appendix:shorterproofs}. Our goal was to show that given a directed family \AgdaType{Œ±}{\AgdaFun{I}{\AgdaExtractSet{\FuncDcpo{ùìì}{ùìî}}}}, and \AgdaType{d}{\AgdaExtractSet{ùìì}}, then \AgdaFunction{f}\AgdaSpace{}\AgdaPair{\AgdaUpperBound{\AgdaBrackets{\FuncDcpo{ùìì}{ùìî}}}{Œ¥}}{d} is the least upper bound of the pointwise family formed by \AgdaBound{Œ±} and \AgdaBound{d}. Our original proof spanned many lines. We first showed that \AgdaFunction{f}\AgdaSpace{}\AgdaPair{\AgdaUpperBound{\AgdaBrackets{\FuncDcpo{ùìì}{ùìî}}}{Œ¥}}{d} is the upper bound, and then that it was the least of the upper bounds, and as such was the least upper bound. However, at the end of the project, when reviewing this proof we notice that this was unnecessary. With our greater understanding, we learn that the least upper bound of \AgdaBound{Œ±} applied to an element \AgdaBound{d}, is by definition the least upper bound of the pointwise family formed by \AgdaBound{Œ±} and \AgdaBound{d}. Therefore, we rewrote this proof simply to be a single line by knowledge of this fact. If time allowed, we would go through all proofs and attempt to make them as readable and elegant as possible.

As mentioned, we also have had to develop our understanding of domain theory. We began from basic knowledge and understanding, where we learned the definitions of a directed family, an upper bound, and more. We then had to build on this to learn more interesting properties, such as proving that the products of two DCPOs form a DCPO. After this, we developed constructions involving continuous functions and our product of DCPOs, along with Tom de Jong's existing developments, to form the Scott model of PCF. This learning was the key focus for someone who comes from a software engineering background, as it required mathematical concepts which we were not familiar with at the beginning. Relating to our previous point, as our understanding in this area grew, as did our proficiency in proving properties surrounding domain theory. We compare this to defining the PCF types and terms, and the operational semantics of PCF. These concepts are familiar to someone with our background. We can easily relate them to what one may see when programming in a language such as Java, and how the operational semantics relates to compilers and interpreters. The concepts we learn and develop in domain theory were perhaps more difficult to relate to, and hence required the most time and effort to form an understanding.

As a result of this lack of initial understanding, our first contribution to the DCPO developments took a considerable amount of time longer than the later proofs. This contribution was that the product of two DCPOs also forms a DCPO under the component-wise ordering. This proof, whilst trivial to somebody with experience in domain theory, was difficult for us due to our unfamiliarity. However, once we overcome this initial learning curve, we possessed enough knowledge to complete proofs surrounding DCPOs with considerably more pace and efficiency.
\paragraph*{Challenges in formalisation.}Another area that was difficult at times, whilst as the project has progressed we have become better at it, was translating the paper proofs we were following into Agda. There were a couple of times throughout the project where we experienced theorems or lemmas that were stated to be ``straightforward induction'', with no detailed proof given. For these, we sometimes had to develop our own proofs. A particularly good example of this was the proofs regarding the applicative approximation relation when we were proving computational adequacy. The first was that \AgdaAppApr{\AgdaApp{M}{\AgdaFix{M}}}{\AgdaFix{M}}. Although a proof was given for this, it did not directly translate into Agda. The other proof was a footnote in Streicher's paper which states it generally holds that \AgdaAppApr{\AgdaReplace{M}{N}}{\AgdaApp{\AgdaLambda{M}}{N}}. Both of these proofs we tried to prove by induction on types, however both became stuck. It seemed our inductive hypothesis was not strong enough. After some assistance and time, we managed to work out that we can prove a more general lemma which both of these proofs follow trivially. This shows that some proofs which may be left out of papers require explicit formalisation in Agda, increasing confidence in the correctness of our proofs.

There was also the proof \AgdaEq{\AgdaFunction{subst}\AgdaSpace{}\AgdaBrackets{\AgdaFunction{extend-with}\AgdaSpace{}\AgdaBound{M‚ÇÅ}\AgdaSpace{}\AgdaBound{f}}\AgdaSpace{}\AgdaBound{M}}{\AgdaReplace{\AgdaBrackets{\AgdaFunction{subst}\AgdaSpace{}\AgdaBrackets{\AgdaFunction{exts}\AgdaSpace{}\AgdaBound{f}}\AgdaSpace{}\AgdaBound{M}}}{M‚ÇÅ}} required in \cref{mainlemma}. This property was mentioned as being true in \cite[Lemma~7.4]{domaintheoreticfoundations}, but without proof. We first turned to \cite{PLFA}, as there are similar proofs surrounding substitution, but for the untyped lambda calculus. Whilst these proofs gave some direction as to how we should attempt to solve the proof, they did not translate directly for PCF. We instead were required to prove three fusion lemmas for the \AgdaFunction{rename} and \AgdaFunction{subst} operations. This ``simple'' proof became hundreds of lines of code, and is another example of how, when formalising proofs in Agda, we are forced to show every detail.

During this project, we have had to learn a lot, and many times there were satisfying moments when we finally managed to complete proofs. However, the one that particularly stands out was the completion of the Scott model. After spending a considerable amount of time and effort learning domain theory, it gave great satisfaction to finally see the knowledge come together to provide us with the denotational semantics of PCF. The statistics of the volume of work are provided in \cref{appendix:codestats}. It also required some creativity at times to reuse Tom de Jong's developments, as his interpretations for \AgdaInductiveConstructor{IfZero} and \AgdaInductiveConstructor{Fix} were not under contexts. This was a milestone in our developments in that we were sure we had learned enough domain theory to be able to construct the model and now could move on to showing computational adequacy.

\end{document}
